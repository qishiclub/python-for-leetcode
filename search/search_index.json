{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python-for-leetcode type hints Evolution of Python Typing Python 3.5 (2015): Introduced type hints via typing module [PEP 484]. Python 3.9 (2020): Added native type hints for collections (e.g., list[str] ) [PEP 585]. Python 3.10 (2021): Added writing union types as X | Y [PEP 604]. Python 3.11 (2022): Added Self [PEP 673] and TypeVarTuple [PEP 646]. Python 3.12 (2023): Introduced Override Decorator [PEP 698]. Python 3.13 (2024): Introduced annotating type forms TypeForm [PEP 747] Since python 3.9: List -> list Dict -> dict Tuple -> tuple Set -> set Deque -> collections.deque DefaultDict -> collections.defaultdict Optional[T] -> T | None flatten 2D array a = [ [1,2,3], [4,5,6], [7,8,9] ] flattened = [item for sublist in a for item in sublist] print(flattened) # [1, 2, 3, 4, 5, 6, 7, 8, 9] # or print(sum(a, [])) # [1, 2, 3, 4, 5, 6, 7, 8, 9] Reverse a string s = \"hello\" # Method 1: Using slicing reversed_s = s[::-1] print(reversed_s) # \"olleh\" # Method 2: Using the `reversed()` function reversed_s = ''.join(reversed(s)) # NOTE `reversed()` returns an iterator print(reversed_s) # \"olleh\" Reverse a list or string str = \"abcde\" print(str[::-1]) list = [1, 2, 3, 4, 5] print(list[::-1]) Array index trick (e.g. Palindrome checking) str = \"abcba\" n = len(str) print(all(str[i] == str[n-i-1] for i in range(n))) str = \"abcba\" print(all(str[i] == str[~i] for i in range(len(str)))) # ~i is -i-1, ~ is bitwise not Tuple unpacking point = (1, 2) x, y = point print(f\"x: {x}, y: {y}\") # x: 1, y: 2 or point = (3, 4) def distance(x, y): return (x**2 + y**2)**0.5 print(distance(*point)) # 5.0 use _ to ignore values point = (1, 2, 3) x, _, z = point print(f\"x: {x}, z: {z}\") # x: 1, z: 3 Boolean as int nums = [4, 6, 8, 3, 5, 7] count = sum(n > 5 for n in nums) # count of numbers greater than 5 print(count) # 3 map nums = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, nums)) # NOTE: map returns an iterator, need to use list() to convert it to a list print(squared) # [1, 4, 9, 16, 25] reduce from functools import reduce from operator import add nums = [1, 2, 3, 4, 5] sum = reduce(add, nums) # sum of all numbers print(sum) # 15 # or using lambda sum = reduce(lambda x, y: x + y, nums) # sum of all numbers print(sum) # 15 defaultdict from collections import defaultdict d = defaultdict(int) # default value is 0 d['a'] += 1 print(d['a']) # 1 # you dont need `setdefault`, which is working with regular `{}` swap variables a, b = b, a # or using `^` a = a ^ b b = a ^ b a = a ^ b chained boolean comparisons if 'a' < 'b' < 'c': if 1 < 2 < 3: # tuple comparison if ('a', 3) < ('b', 2) < ('c', 1): Multiple assignment When assign multiple variables to the same value, you can do it in one line: a = b = c = 0 match syntax Since python 3.10, you can use match syntax to match patterns in data structures (this is what is used in match in other languages): def process(data): match data: case int(value): print(f\"Integer: {value}\") case str(value): print(f\"String: {value}\") case list(): print(\"List: {data}\") case dict(): print(\"Dictionary: {data}\") case _: print(\"Unknown type\") process(42) # Integer: 42 process(\"hello\") # String: hello process([1, 2, 3]) # List: [1, 2, 3] process({\"key\": \"value\"}) # Dictionary: {'key': 'value'} process({1, 2, 3}) # Unknown type process(None) # Unknown type Or you can match exact values: def process(data): match data: case 1: print(\"One\") case 2: print(\"Two\") case _: print(\"Other\") process(1) # One process(2) # Two process(3) # Other Rounding issue for negative numbers print(5/2) # 2.5 print(5//2) # 2 print(-3//2) # -2 print(int(-3/2)) # -1 mod issue for negative numbers print(5 % 2) # 1 print(-10 % 3) # 2 import math print(math.fmod(-10, 3)) # -1.0 numbers never overflow python numbers are unbounded so they never overflow. print(math.pow(2, 200)) # 1.6069380442589903e+60 print(math.pow(2, 200) < math.inf) # True Reference NeetCode: Python for Coding Interviews","title":"Home"},{"location":"#python-for-leetcode","text":"","title":"python-for-leetcode"},{"location":"#type-hints","text":"Evolution of Python Typing Python 3.5 (2015): Introduced type hints via typing module [PEP 484]. Python 3.9 (2020): Added native type hints for collections (e.g., list[str] ) [PEP 585]. Python 3.10 (2021): Added writing union types as X | Y [PEP 604]. Python 3.11 (2022): Added Self [PEP 673] and TypeVarTuple [PEP 646]. Python 3.12 (2023): Introduced Override Decorator [PEP 698]. Python 3.13 (2024): Introduced annotating type forms TypeForm [PEP 747] Since python 3.9: List -> list Dict -> dict Tuple -> tuple Set -> set Deque -> collections.deque DefaultDict -> collections.defaultdict Optional[T] -> T | None","title":"type hints"},{"location":"#flatten-2d-array","text":"a = [ [1,2,3], [4,5,6], [7,8,9] ] flattened = [item for sublist in a for item in sublist] print(flattened) # [1, 2, 3, 4, 5, 6, 7, 8, 9] # or print(sum(a, [])) # [1, 2, 3, 4, 5, 6, 7, 8, 9]","title":"flatten 2D array"},{"location":"#reverse-a-string","text":"s = \"hello\" # Method 1: Using slicing reversed_s = s[::-1] print(reversed_s) # \"olleh\" # Method 2: Using the `reversed()` function reversed_s = ''.join(reversed(s)) # NOTE `reversed()` returns an iterator print(reversed_s) # \"olleh\"","title":"Reverse a string"},{"location":"#reverse-a-list-or-string","text":"str = \"abcde\" print(str[::-1]) list = [1, 2, 3, 4, 5] print(list[::-1])","title":"Reverse a list or string"},{"location":"#array-index-trick-eg-palindrome-checking","text":"str = \"abcba\" n = len(str) print(all(str[i] == str[n-i-1] for i in range(n))) str = \"abcba\" print(all(str[i] == str[~i] for i in range(len(str)))) # ~i is -i-1, ~ is bitwise not","title":"Array index trick (e.g. Palindrome checking)"},{"location":"#tuple-unpacking","text":"point = (1, 2) x, y = point print(f\"x: {x}, y: {y}\") # x: 1, y: 2 or point = (3, 4) def distance(x, y): return (x**2 + y**2)**0.5 print(distance(*point)) # 5.0","title":"Tuple unpacking"},{"location":"#use-_-to-ignore-values","text":"point = (1, 2, 3) x, _, z = point print(f\"x: {x}, z: {z}\") # x: 1, z: 3","title":"use _ to ignore values"},{"location":"#boolean-as-int","text":"nums = [4, 6, 8, 3, 5, 7] count = sum(n > 5 for n in nums) # count of numbers greater than 5 print(count) # 3","title":"Boolean as int"},{"location":"#map","text":"nums = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, nums)) # NOTE: map returns an iterator, need to use list() to convert it to a list print(squared) # [1, 4, 9, 16, 25]","title":"map"},{"location":"#reduce","text":"from functools import reduce from operator import add nums = [1, 2, 3, 4, 5] sum = reduce(add, nums) # sum of all numbers print(sum) # 15 # or using lambda sum = reduce(lambda x, y: x + y, nums) # sum of all numbers print(sum) # 15","title":"reduce"},{"location":"#defaultdict","text":"from collections import defaultdict d = defaultdict(int) # default value is 0 d['a'] += 1 print(d['a']) # 1 # you dont need `setdefault`, which is working with regular `{}`","title":"defaultdict"},{"location":"#swap-variables","text":"a, b = b, a # or using `^` a = a ^ b b = a ^ b a = a ^ b","title":"swap variables"},{"location":"#chained-boolean-comparisons","text":"if 'a' < 'b' < 'c': if 1 < 2 < 3: # tuple comparison if ('a', 3) < ('b', 2) < ('c', 1):","title":"chained boolean comparisons"},{"location":"#multiple-assignment","text":"When assign multiple variables to the same value, you can do it in one line: a = b = c = 0","title":"Multiple assignment"},{"location":"#match-syntax","text":"Since python 3.10, you can use match syntax to match patterns in data structures (this is what is used in match in other languages): def process(data): match data: case int(value): print(f\"Integer: {value}\") case str(value): print(f\"String: {value}\") case list(): print(\"List: {data}\") case dict(): print(\"Dictionary: {data}\") case _: print(\"Unknown type\") process(42) # Integer: 42 process(\"hello\") # String: hello process([1, 2, 3]) # List: [1, 2, 3] process({\"key\": \"value\"}) # Dictionary: {'key': 'value'} process({1, 2, 3}) # Unknown type process(None) # Unknown type Or you can match exact values: def process(data): match data: case 1: print(\"One\") case 2: print(\"Two\") case _: print(\"Other\") process(1) # One process(2) # Two process(3) # Other","title":"match syntax"},{"location":"#rounding-issue-for-negative-numbers","text":"print(5/2) # 2.5 print(5//2) # 2 print(-3//2) # -2 print(int(-3/2)) # -1","title":"Rounding issue for negative numbers"},{"location":"#mod-issue-for-negative-numbers","text":"print(5 % 2) # 1 print(-10 % 3) # 2 import math print(math.fmod(-10, 3)) # -1.0","title":"mod issue for negative numbers"},{"location":"#numbers-never-overflow","text":"python numbers are unbounded so they never overflow. print(math.pow(2, 200)) # 1.6069380442589903e+60 print(math.pow(2, 200) < math.inf) # True","title":"numbers never overflow"},{"location":"#reference","text":"NeetCode: Python for Coding Interviews","title":"Reference"},{"location":"concurrency/","text":"Concurrency What is concurrency? Concurrency is the ability of a program to execute multiple tasks simultaneously. It allows for better resource utilization and can improve the performance of applications, especially those that are I/O-bound or require parallel processing. There are mainly three types of concurrency in Python: Threading : Using threads to run multiple tasks concurrently within a single process. Suitable for I/O-bound tasks. Multiprocessing : Using multiple processes to run tasks concurrently. Suitable for CPU-bound tasks. Asyncio : Using asynchronous programming to run tasks concurrently. Suitable for I/O-bound tasks. Threading basic threading example: import threading import time from concurrent.futures import ThreadPoolExecutor def threaded_function(): for number in range(3): print(f\"Printing from {threading.current_thread().name}. {number=}\") time.sleep(0.1) with ThreadPoolExecutor(max_workers=4, thread_name_prefix=\"Worker\") as executor: for _ in range(4): executor.submit(threaded_function) # Output: # Printing from Worker_0. number=0 # Printing from Worker_1. number=0 # Printing from Worker_2. number=0 # Printing from Worker_3. number=0 # Printing from Worker_0. number=1 # Printing from Worker_2. number=1 # Printing from Worker_1. number=1 # Printing from Worker_3. number=1 # Printing from Worker_0. number=2 # Printing from Worker_2. number=2 # Printing from Worker_1. number=2 # Printing from Worker_3. number=2 Thread safety issues occur because of two factors: Shared state : When multiple threads access and modify the same data simultaneously, it can lead to race conditions, causing inconsistent or unpredictable results. Non-atomic operations : Operations that aren\u2019t atomic (indivisible) can be interrupted midway by other threads, resulting in partial updates or corrupted data. Using threading.Lock for mutual exclusion import threading import time from concurrent.futures import ThreadPoolExecutor class BankAccount: def __init__(self, balance=0): self.balance = balance self.account_lock = threading.Lock() def withdraw(self, amount): with self.account_lock: if self.balance >= amount: new_balance = self.balance - amount print(f\"Withdrawing {amount}...\") time.sleep(0.1) # Simulate a delay self.balance = new_balance else: raise ValueError(\"Insufficient balance\") def deposit(self, amount): with self.account_lock: new_balance = self.balance + amount print(f\"Depositing {amount}...\") time.sleep(0.1) # Simulate a delay self.balance = new_balance account = BankAccount(1000) with ThreadPoolExecutor(max_workers=3) as executor: executor.submit(account.withdraw, 700) executor.submit(account.deposit, 1000) executor.submit(account.withdraw, 300) print(f\"Final account balance: {account.balance}\") # Output: Withdrawing 700... Depositing 1000... Withdrawing 300... Final account balance: 1000 threading.RLock for Reentrant Locking Reentrant locks ( threading.RLock ) allow a thread to acquire the same lock multiple times without causing a deadlock. This is useful when a thread needs to call a function that requires the same lock it already holds. Key points: - Reentrant : A thread can acquire the lock multiple times without blocking itself. - Release : Lock if fully released the same number of times it was acquired. import threading rlock = threading.RLock() def inner_task(): with rlock: print(\"Inner task acquired lock.\") def outer_task(): with rlock: print(\"Outer task acquired lock.\") inner_task() thread = threading.Thread(target=outer_task) thread.start() thread.join() Limiting Access With Semaphore Semaphore is a synchronization primitive that allows a limited number of threads to access a shared resource concurrently. It's especially useful in secnarios like: Limiting the number of connections to a server Controlling access to limited resources (e.g., database connections, file handles) Key points: Initialized with a positive integer, representing available permits. .acquire() decrements the semaphore count; threads wait if the count is zero. .release() increments the semaphore count, signaling that a permit is available. import threading import time semaphore = threading.Semaphore(2) # max 2 threads simultaneously def worker(worker_id): print(f\"Worker {worker_id} waiting...\") with semaphore: print(f\"Worker {worker_id} working...\") time.sleep(2) print(f\"Worker {worker_id} done.\") threads = [threading.Thread(target=worker, args=(i,)) for i in range(4)] for t in threads: t.start() for t in threads: t.join() # Output: # Worker 0 waiting... # Worker 0 working... # Worker 1 waiting... # Worker 1 working... # Worker 2 waiting... # Worker 3 waiting... # Worker 0 done. # Worker 2 working... # Worker 1 done. # Worker 3 working... # Worker 2 done. # Worker 3 done. Using Synchronization Primitives for communication and coordination Events for Signaling import threading import time event = threading.Event() def waiter(): print(\"Waiter thread is waiting for event...\") event.wait() print(\"Waiter thread received event!\") def notifier(): print(\"Notifier thread sleeping...\") time.sleep(2) event.set() print(\"Notifier thread set event.\") t1 = threading.Thread(target=waiter) t2 = threading.Thread(target=notifier) t1.start() t2.start() t1.join() t2.join() # Output: # Waiter thread is waiting for event... # Notifier thread sleeping... # Notifier thread set event. # Waiter thread received event! Conditions for Conditional Waiting A Condition ( threading.Condition ) enables threads to pause execution and wait until cetain conditions are met. It's ideal for producer-consumer scenarios, where one or more threads produce data and others consume it. Key points: Threads call .wait() to block until notified. Use .notify() or .notify_all() to wake up waiting threads ( notify() for one thread, notify_all() for all). import threading import time condition = threading.Condition() queue = [] def consumer(): with condition: print(\"Consumer waiting for item...\") while not queue: condition.wait() item = queue.pop(0) print(f\"Consumer got item: {item}\") def producer(): with condition: print(\"Producer creating item...\") queue.append(\"data\") condition.notify() c = threading.Thread(target=consumer) p = threading.Thread(target=producer) c.start() time.sleep(1) # ensure consumer waits first p.start() c.join() p.join() # Output: # Consumer waiting for item... # Producer creating item... # Consumer got item: data Barriers for Coordination Barrier(parties, action=None, timeout=None) import threading import time # Barrier for synchronizing exactly 3 threads barrier = threading.Barrier(3) def worker(worker_id): print(f\"Worker {worker_id}: preparing\") time.sleep(worker_id) # simulate varying preparation times print(f\"Worker {worker_id}: ready and waiting at barrier\") barrier.wait() # threads pause here until all 3 have called wait() print(f\"Worker {worker_id}: passed the barrier, continuing\") # Create exactly 3 threads threads = [ threading.Thread(target=worker, args=(i,)) for i in range(3) ] for t in threads: t.start() for t in threads: t.join() print(\"All threads have passed the barrier.\") # Output: # Worker 0: preparing # Worker 1: preparing # Worker 2: preparing # Worker 0: ready and waiting at barrier # Worker 1: ready and waiting at barrier # Worker 2: ready and waiting at barrier # Worker 2: passed the barrier, continuing # Worker 0: passed the barrier, continuing # Worker 1: passed the barrier, continuing # All threads have passed the barrier. Primitive Use-case Key operations RLock Reentrant locking acquire() , release() Semaphore Limit concurrent access acquire() , release() Event Signaling between threads set() , clear() , wait() Condition Conditional waiting wait() , notify() , notify_all() Barrier Coordination among threads wait() Summary Identify race conditions in code Use Lock and RLock to protect shared resources Use Semaphore to limit concurrent access to resources Leverage Event for signaling between threads Use Condition for complex thread communication Use Barrier for coordinating multiple threads","title":"Concurrency"},{"location":"concurrency/#concurrency","text":"","title":"Concurrency"},{"location":"concurrency/#what-is-concurrency","text":"Concurrency is the ability of a program to execute multiple tasks simultaneously. It allows for better resource utilization and can improve the performance of applications, especially those that are I/O-bound or require parallel processing. There are mainly three types of concurrency in Python: Threading : Using threads to run multiple tasks concurrently within a single process. Suitable for I/O-bound tasks. Multiprocessing : Using multiple processes to run tasks concurrently. Suitable for CPU-bound tasks. Asyncio : Using asynchronous programming to run tasks concurrently. Suitable for I/O-bound tasks.","title":"What is concurrency?"},{"location":"concurrency/#threading","text":"basic threading example: import threading import time from concurrent.futures import ThreadPoolExecutor def threaded_function(): for number in range(3): print(f\"Printing from {threading.current_thread().name}. {number=}\") time.sleep(0.1) with ThreadPoolExecutor(max_workers=4, thread_name_prefix=\"Worker\") as executor: for _ in range(4): executor.submit(threaded_function) # Output: # Printing from Worker_0. number=0 # Printing from Worker_1. number=0 # Printing from Worker_2. number=0 # Printing from Worker_3. number=0 # Printing from Worker_0. number=1 # Printing from Worker_2. number=1 # Printing from Worker_1. number=1 # Printing from Worker_3. number=1 # Printing from Worker_0. number=2 # Printing from Worker_2. number=2 # Printing from Worker_1. number=2 # Printing from Worker_3. number=2 Thread safety issues occur because of two factors: Shared state : When multiple threads access and modify the same data simultaneously, it can lead to race conditions, causing inconsistent or unpredictable results. Non-atomic operations : Operations that aren\u2019t atomic (indivisible) can be interrupted midway by other threads, resulting in partial updates or corrupted data.","title":"Threading"},{"location":"concurrency/#using-threadinglock-for-mutual-exclusion","text":"import threading import time from concurrent.futures import ThreadPoolExecutor class BankAccount: def __init__(self, balance=0): self.balance = balance self.account_lock = threading.Lock() def withdraw(self, amount): with self.account_lock: if self.balance >= amount: new_balance = self.balance - amount print(f\"Withdrawing {amount}...\") time.sleep(0.1) # Simulate a delay self.balance = new_balance else: raise ValueError(\"Insufficient balance\") def deposit(self, amount): with self.account_lock: new_balance = self.balance + amount print(f\"Depositing {amount}...\") time.sleep(0.1) # Simulate a delay self.balance = new_balance account = BankAccount(1000) with ThreadPoolExecutor(max_workers=3) as executor: executor.submit(account.withdraw, 700) executor.submit(account.deposit, 1000) executor.submit(account.withdraw, 300) print(f\"Final account balance: {account.balance}\") # Output: Withdrawing 700... Depositing 1000... Withdrawing 300... Final account balance: 1000","title":"Using threading.Lock for mutual exclusion"},{"location":"concurrency/#threadingrlock-for-reentrant-locking","text":"Reentrant locks ( threading.RLock ) allow a thread to acquire the same lock multiple times without causing a deadlock. This is useful when a thread needs to call a function that requires the same lock it already holds. Key points: - Reentrant : A thread can acquire the lock multiple times without blocking itself. - Release : Lock if fully released the same number of times it was acquired. import threading rlock = threading.RLock() def inner_task(): with rlock: print(\"Inner task acquired lock.\") def outer_task(): with rlock: print(\"Outer task acquired lock.\") inner_task() thread = threading.Thread(target=outer_task) thread.start() thread.join()","title":"threading.RLock for Reentrant Locking"},{"location":"concurrency/#limiting-access-with-semaphore","text":"Semaphore is a synchronization primitive that allows a limited number of threads to access a shared resource concurrently. It's especially useful in secnarios like: Limiting the number of connections to a server Controlling access to limited resources (e.g., database connections, file handles) Key points: Initialized with a positive integer, representing available permits. .acquire() decrements the semaphore count; threads wait if the count is zero. .release() increments the semaphore count, signaling that a permit is available. import threading import time semaphore = threading.Semaphore(2) # max 2 threads simultaneously def worker(worker_id): print(f\"Worker {worker_id} waiting...\") with semaphore: print(f\"Worker {worker_id} working...\") time.sleep(2) print(f\"Worker {worker_id} done.\") threads = [threading.Thread(target=worker, args=(i,)) for i in range(4)] for t in threads: t.start() for t in threads: t.join() # Output: # Worker 0 waiting... # Worker 0 working... # Worker 1 waiting... # Worker 1 working... # Worker 2 waiting... # Worker 3 waiting... # Worker 0 done. # Worker 2 working... # Worker 1 done. # Worker 3 working... # Worker 2 done. # Worker 3 done.","title":"Limiting Access With Semaphore"},{"location":"concurrency/#using-synchronization-primitives-for-communication-and-coordination","text":"","title":"Using Synchronization Primitives for communication and coordination"},{"location":"concurrency/#events-for-signaling","text":"import threading import time event = threading.Event() def waiter(): print(\"Waiter thread is waiting for event...\") event.wait() print(\"Waiter thread received event!\") def notifier(): print(\"Notifier thread sleeping...\") time.sleep(2) event.set() print(\"Notifier thread set event.\") t1 = threading.Thread(target=waiter) t2 = threading.Thread(target=notifier) t1.start() t2.start() t1.join() t2.join() # Output: # Waiter thread is waiting for event... # Notifier thread sleeping... # Notifier thread set event. # Waiter thread received event!","title":"Events for Signaling"},{"location":"concurrency/#conditions-for-conditional-waiting","text":"A Condition ( threading.Condition ) enables threads to pause execution and wait until cetain conditions are met. It's ideal for producer-consumer scenarios, where one or more threads produce data and others consume it. Key points: Threads call .wait() to block until notified. Use .notify() or .notify_all() to wake up waiting threads ( notify() for one thread, notify_all() for all). import threading import time condition = threading.Condition() queue = [] def consumer(): with condition: print(\"Consumer waiting for item...\") while not queue: condition.wait() item = queue.pop(0) print(f\"Consumer got item: {item}\") def producer(): with condition: print(\"Producer creating item...\") queue.append(\"data\") condition.notify() c = threading.Thread(target=consumer) p = threading.Thread(target=producer) c.start() time.sleep(1) # ensure consumer waits first p.start() c.join() p.join() # Output: # Consumer waiting for item... # Producer creating item... # Consumer got item: data","title":"Conditions for Conditional Waiting"},{"location":"concurrency/#barriers-for-coordination","text":"Barrier(parties, action=None, timeout=None) import threading import time # Barrier for synchronizing exactly 3 threads barrier = threading.Barrier(3) def worker(worker_id): print(f\"Worker {worker_id}: preparing\") time.sleep(worker_id) # simulate varying preparation times print(f\"Worker {worker_id}: ready and waiting at barrier\") barrier.wait() # threads pause here until all 3 have called wait() print(f\"Worker {worker_id}: passed the barrier, continuing\") # Create exactly 3 threads threads = [ threading.Thread(target=worker, args=(i,)) for i in range(3) ] for t in threads: t.start() for t in threads: t.join() print(\"All threads have passed the barrier.\") # Output: # Worker 0: preparing # Worker 1: preparing # Worker 2: preparing # Worker 0: ready and waiting at barrier # Worker 1: ready and waiting at barrier # Worker 2: ready and waiting at barrier # Worker 2: passed the barrier, continuing # Worker 0: passed the barrier, continuing # Worker 1: passed the barrier, continuing # All threads have passed the barrier. Primitive Use-case Key operations RLock Reentrant locking acquire() , release() Semaphore Limit concurrent access acquire() , release() Event Signaling between threads set() , clear() , wait() Condition Conditional waiting wait() , notify() , notify_all() Barrier Coordination among threads wait()","title":"Barriers for Coordination"},{"location":"concurrency/#summary","text":"Identify race conditions in code Use Lock and RLock to protect shared resources Use Semaphore to limit concurrent access to resources Leverage Event for signaling between threads Use Condition for complex thread communication Use Barrier for coordinating multiple threads","title":"Summary"},{"location":"data-structure-complexities/","text":"data structure complexities List list list is internally represented as a dynamic array. It allows for efficient random access and appending, but inserting or deleting elements at arbitrary positions can be costly due to the need to shift elements. Operation Average Case Worst Case Notes Index (list[i]) O(1) O(1) Direct access via index Append (append) O(1) amortized O(1) amortized Occasionally O(n) when resizing Insert/Delete (end) O(1) amortized O(1) amortized Append/pop at end Insert/Delete (front) O(n) O(n) Shifts subsequent elements Membership (x in l) O(n) O(n) Linear search Pop (pop) O(1) (end) O(n) (front) O(1) for pop(), O(n) for pop(i) Sort (sort()) O(n log n) O(n log n) Timsort Slice (list[a:b]) O(b-a) O(b-a) Depends on slice length Deque collections.deque deque is represented internally as a doubly linked list, allowing for efficient appends and pops from both ends. However, it does not support random access like lists. Operation Average Case Worst Case Notes Append (append) O(1) O(1) Efficient at both ends Pop (pop) O(1) O(1) Efficient at both ends Append/Pop (front) O(1) O(1) Efficient at both ends Index (deque[i]) O(n) O(n) No direct indexing (linear traversal) Membership (x in dq) O(n) O(n) Linear search Set set set is implemented as a hash table, allowing for average O(1) time complexity for membership tests, insertions, and deletions. However, in the worst case, these operations can degrade to O(n) due to hash collisions. Operation Average Case Worst Case Notes Membership (x in s) O(1) O(n) Rarely O(n) with hash collisions Insert/Delete (add/remove) O(1) O(n) Rarely O(n) with hash collisions Union/Intersection O(len(s1)+len(s2)) O(len(s1)*len(s2)) Intersection worst-case depends on hash Iteration (for x in s) O(n) O(n) Iterates through all elements Dictionary dict Operation Average Case Worst Case Notes Lookup (d[key]) O(1) O(n) Rarely O(n) with hash collisions Insert/Delete O(1) O(n) Rarely O(n) with hash collisions Membership (key in d) O(1) O(n) Rarely O(n) with hash collisions Iteration (for key in d) O(n) O(n) Iterates through all keys sortedcontainers module Operation Average Case Worst Case Notes Insert (add) O(log n) O(log n) e.g., SortedList, SortedDict Delete O(log n) O(log n) Balanced binary-tree implementations Membership O(log n) O(log n) Efficient sorted structures Indexing (container[i]) O(log n) O(log n) Efficient indexing Iteration (for x in c) O(n) O(n) Iterates through all elements Heap (PriorityQueue) (heapq) Operation Average Case Worst Case Notes Push (heappush) O(log n) O(log n) Maintains heap invariant Pop (heappop) O(log n) O(log n) Retrieves/removes smallest element Peek (heap[0]) O(1) O(1) Retrieves smallest without removal Heapify (heapify) O(n) O(n) Linear-time heap initialization Tuple tuple Operation Average Case Worst Case Notes Indexing (tuple[i]) O(1) O(1) Immutable; direct index Membership (x in t) O(n) O(n) Linear search Concatenation (t1 + t2) O(n+m) O(n+m) Creates a new tuple Common Pitfalls to Keep in Mind: List Insert/Delete: O(n) time if inserting/removing elements at front or middle (shifting required). Dict/Set worst-case: O(n) lookup due to hash collisions (rare but possible). Deque indexing: Not efficient (O(n)), use lists if random access is frequent. Sorted Containers: Use external libraries (sortedcontainers) for efficient sorted insertions/deletions/indexing (standard Python does not provide balanced binary search trees).","title":"Data Structure Complexities"},{"location":"data-structure-complexities/#data-structure-complexities","text":"","title":"data structure complexities"},{"location":"data-structure-complexities/#list-list","text":"list is internally represented as a dynamic array. It allows for efficient random access and appending, but inserting or deleting elements at arbitrary positions can be costly due to the need to shift elements. Operation Average Case Worst Case Notes Index (list[i]) O(1) O(1) Direct access via index Append (append) O(1) amortized O(1) amortized Occasionally O(n) when resizing Insert/Delete (end) O(1) amortized O(1) amortized Append/pop at end Insert/Delete (front) O(n) O(n) Shifts subsequent elements Membership (x in l) O(n) O(n) Linear search Pop (pop) O(1) (end) O(n) (front) O(1) for pop(), O(n) for pop(i) Sort (sort()) O(n log n) O(n log n) Timsort Slice (list[a:b]) O(b-a) O(b-a) Depends on slice length","title":"List list"},{"location":"data-structure-complexities/#deque-collectionsdeque","text":"deque is represented internally as a doubly linked list, allowing for efficient appends and pops from both ends. However, it does not support random access like lists. Operation Average Case Worst Case Notes Append (append) O(1) O(1) Efficient at both ends Pop (pop) O(1) O(1) Efficient at both ends Append/Pop (front) O(1) O(1) Efficient at both ends Index (deque[i]) O(n) O(n) No direct indexing (linear traversal) Membership (x in dq) O(n) O(n) Linear search","title":"Deque collections.deque"},{"location":"data-structure-complexities/#set-set","text":"set is implemented as a hash table, allowing for average O(1) time complexity for membership tests, insertions, and deletions. However, in the worst case, these operations can degrade to O(n) due to hash collisions. Operation Average Case Worst Case Notes Membership (x in s) O(1) O(n) Rarely O(n) with hash collisions Insert/Delete (add/remove) O(1) O(n) Rarely O(n) with hash collisions Union/Intersection O(len(s1)+len(s2)) O(len(s1)*len(s2)) Intersection worst-case depends on hash Iteration (for x in s) O(n) O(n) Iterates through all elements","title":"Set set"},{"location":"data-structure-complexities/#dictionary-dict","text":"Operation Average Case Worst Case Notes Lookup (d[key]) O(1) O(n) Rarely O(n) with hash collisions Insert/Delete O(1) O(n) Rarely O(n) with hash collisions Membership (key in d) O(1) O(n) Rarely O(n) with hash collisions Iteration (for key in d) O(n) O(n) Iterates through all keys","title":"Dictionary dict"},{"location":"data-structure-complexities/#sortedcontainers-module","text":"Operation Average Case Worst Case Notes Insert (add) O(log n) O(log n) e.g., SortedList, SortedDict Delete O(log n) O(log n) Balanced binary-tree implementations Membership O(log n) O(log n) Efficient sorted structures Indexing (container[i]) O(log n) O(log n) Efficient indexing Iteration (for x in c) O(n) O(n) Iterates through all elements","title":"sortedcontainers module"},{"location":"data-structure-complexities/#heap-priorityqueue-heapq","text":"Operation Average Case Worst Case Notes Push (heappush) O(log n) O(log n) Maintains heap invariant Pop (heappop) O(log n) O(log n) Retrieves/removes smallest element Peek (heap[0]) O(1) O(1) Retrieves smallest without removal Heapify (heapify) O(n) O(n) Linear-time heap initialization","title":"Heap (PriorityQueue) (heapq)"},{"location":"data-structure-complexities/#tuple-tuple","text":"Operation Average Case Worst Case Notes Indexing (tuple[i]) O(1) O(1) Immutable; direct index Membership (x in t) O(n) O(n) Linear search Concatenation (t1 + t2) O(n+m) O(n+m) Creates a new tuple","title":"Tuple tuple"},{"location":"data-structure-complexities/#common-pitfalls-to-keep-in-mind","text":"List Insert/Delete: O(n) time if inserting/removing elements at front or middle (shifting required). Dict/Set worst-case: O(n) lookup due to hash collisions (rare but possible). Deque indexing: Not efficient (O(n)), use lists if random access is frequent. Sorted Containers: Use external libraries (sortedcontainers) for efficient sorted insertions/deletions/indexing (standard Python does not provide balanced binary search trees).","title":"Common Pitfalls to Keep in Mind:"},{"location":"python-beginner-intermediate-guide/","text":"Python Beginner/Intermediate Guide to Functions, DS, & Techniques Techniques list/dict/set... comprehensions nums = [1, 2, 3, 4, 5] new_nums = [num for num in nums if num >= 3] dict = {'a': 1, 'b': 2, 'c': 3} new_dict = {key: value * 2 if value >= 2 else value for key, value in dict.items() } # values = [(expression_one) if (boolean) else (expression_two) for (item) in (iterable)] using booleans as values Since python does not have strict types, you can use booleans as values in dictionaries or lists. # s1 = \"abcdef\" # s2 = \"abc123\" num_in_common = 0 for i in range(len(s1)): if s1[i] == s2[i]: num_in_common += 1 print(num_in_common) # 3 # or using `s1[i] == s2[i]` as a boolean value num_in_common = 0 for i in range(len(s1)): num_in_common += s1[i] == s2[i] print(num_in_common) # 3 lambda functions lambda function is a small anonymous function. It can take any number of arguments, but can only have one expression. def double(num): return num * 2 print(double(5)) # 10 # or using a lambda function double = lambda num: num * 2 print(double(5)) # 10 or using lambda function in sorting for point(x, y) points = [(1, 2), (3, 6), (5, 6), (3, 5), (7, 8)] points.sort(key=lambda point: (-point[0], point[1])) # sort by x desc, y asc print(points) # [(7, 8), (5, 6), (3, 5), (3, 6), (1, 2)] Other examples of functions which could take in a key argument include max , min , many heapq methods, bisect methods, etc. Functions enumerate for i in range(len(nums)): print(f\"{i}: {nums[i]}\") # or using enumerate for i, num in enumerate(nums): print(f\"{i}: {num}\") zip zip is a built-in function that takes iterables (can be zero or more), aggregates them in a tuple, and returns it. list1 = [1, 2, 3, 4] list2 = [4, 5, 6] # using min length for i in range(min(len(list1), len(list2))): print(f\"{list1[i]}: {list2[i]}\") # 1: 4, 2: 5, 3: 6 # or using zip for num1, num2 in zip(list1, list2): print(f\"{num1}: {num2}\") # 1: 4, 2: 5, 3: 6 all all returns True if all elements of the iterable are true (or if the iterable is empty). # using all for num in nums: if num >= value: return False return True # or using all return all(num < value for num in nums) any any returns True if any element of the iterable is true. If the iterable is empty, return False. # using any for num in nums: if num >= value: return True return False # or using any return any(num >= value for num in nums) sorted sorted is a built-in function that returns a new sorted list from the elements of any iterable. nums = [5, 2, 3, 1, 4] # using sorted sorted_nums = sorted(nums) # [1, 2, 3, 4, 5] # or using sort nums.sort() # [1, 2, 3, 4, 5] The difference between sorted(iterable) and sort() is that sorted() returns a new list, while sort() modifies the list in place and returns None . bin bin converts an integer number to a binary string prefixed with \"0b\". num = 5 print(bin(num)) # 0b101 # and converts it back to an integer using `int` print(int(bin(num), 2)) # 5 map map(function, iterable) applies the function to all items in the iterable and returns a map object (which is an iterator). nums = [1, 2, 3, 4, 5] # using map squared_nums = list(map(lambda x: x ** 2, nums)) # [1, 4, 9, 16, 25] reduce reduce(function, iterable) applies the function cumulatively to the items of the iterable, from left to right, so as to reduce the iterable to a single value. from functools import reduce def add(x, y): return x + y reduce (add, [1, 2, 3, 4, 5]) # 15 # which calcuates as (((1 + 2) + 3) + 4) + 5 filter filter(function, iterable) constructs an iterator from those elements of iterable for which function returns true. nums = [1, 2, 3, 4, 5] # using filter even_nums = list(filter(lambda x: x % 2 == 0, nums)) # [2, 4] reversed reversed returns a reverse iterator. The original iterable is not modified. nums = [1, 2, 3, 4, 5] # using reversed reversed_nums = list(reversed(nums)) # [5, 4, 3, 2, 1] # or using sort nums.sort(reverse=True) # [5, 4, 3, 2, 1] Data Structures dictionary counter from collections import Counter nums = [1, 2, 3, 4, 5, 1, 2, 3] counter = Counter(nums) print(counter) # Counter({1: 2, 2: 2, 3: 2, 4: 1, 5: 1}) set nums = [1, 2, 3, 4, 5] # using set unique_nums = set(nums) # {1, 2, 3, 4, 5} # or using list(dict.fromkeys) unique_nums = list(dict.fromkeys(nums)) # [1, 2, 3, 4, 5] deque Packages bisect The module provides support for maintaining a list in sorted order without having to sort the list after each insertion. There are two main functions in the bisect module: bisect_left : Find the index where to insert an element to keep the list sorted. bisect_right : Find the index where to insert an element to keep the list sorted, but if the element is already present, it will be inserted to the right of the existing elements. heapq The module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. heapify : Transform a list into a heap, in-place, in linear time. heappush : Push the value item onto the heap, maintaining the heap invariant. heappop : Pop and return the smallest item from the heap, maintaining the heap invariant. Miscellaneous If (not) _ # check if list is empty if len(nums) == 0: print(\"List is empty\") # or if not nums: print(\"List is empty\") Multiplying strings / lists In-line If/Else statements @lru_cache , @cache @lru_cache caches the result of function calls up to a certain size ( maxsize ). When the cache reaches this limit, the least recently used entries are discarded. Setting maxisize=None makes the cache unbounded. from functools import lru_cache @lru_cache(maxsize=None) def fibonacci(n): if n < 2: return n return fibonacci(n - 1) + fibonacci(n - 2) print(fibonacci(10)) # 55 With python 3.9+, you can use @cache instead of @lru_cache(maxsize=None) . from functools import cache @cache def fibonacci(n): if n < 2: return n return fibonacci(n - 1) + fibonacci(n - 2) print(fibonacci(10)) # 55 float('inf') , math.inf float('inf') is the same as math.inf , meaning positive infinity. float('-inf') is the same as -math.inf , meaning negative infinity.","title":"Python Beginner/Intermediate Guide"},{"location":"python-beginner-intermediate-guide/#python-beginnerintermediate-guide-to-functions-ds-techniques","text":"","title":"Python Beginner/Intermediate Guide to Functions, DS, &amp; Techniques"},{"location":"python-beginner-intermediate-guide/#techniques","text":"","title":"Techniques"},{"location":"python-beginner-intermediate-guide/#listdictset-comprehensions","text":"nums = [1, 2, 3, 4, 5] new_nums = [num for num in nums if num >= 3] dict = {'a': 1, 'b': 2, 'c': 3} new_dict = {key: value * 2 if value >= 2 else value for key, value in dict.items() } # values = [(expression_one) if (boolean) else (expression_two) for (item) in (iterable)]","title":"list/dict/set... comprehensions"},{"location":"python-beginner-intermediate-guide/#using-booleans-as-values","text":"Since python does not have strict types, you can use booleans as values in dictionaries or lists. # s1 = \"abcdef\" # s2 = \"abc123\" num_in_common = 0 for i in range(len(s1)): if s1[i] == s2[i]: num_in_common += 1 print(num_in_common) # 3 # or using `s1[i] == s2[i]` as a boolean value num_in_common = 0 for i in range(len(s1)): num_in_common += s1[i] == s2[i] print(num_in_common) # 3","title":"using booleans as values"},{"location":"python-beginner-intermediate-guide/#lambda-functions","text":"lambda function is a small anonymous function. It can take any number of arguments, but can only have one expression. def double(num): return num * 2 print(double(5)) # 10 # or using a lambda function double = lambda num: num * 2 print(double(5)) # 10 or using lambda function in sorting for point(x, y) points = [(1, 2), (3, 6), (5, 6), (3, 5), (7, 8)] points.sort(key=lambda point: (-point[0], point[1])) # sort by x desc, y asc print(points) # [(7, 8), (5, 6), (3, 5), (3, 6), (1, 2)] Other examples of functions which could take in a key argument include max , min , many heapq methods, bisect methods, etc.","title":"lambda functions"},{"location":"python-beginner-intermediate-guide/#functions","text":"","title":"Functions"},{"location":"python-beginner-intermediate-guide/#enumerate","text":"for i in range(len(nums)): print(f\"{i}: {nums[i]}\") # or using enumerate for i, num in enumerate(nums): print(f\"{i}: {num}\")","title":"enumerate"},{"location":"python-beginner-intermediate-guide/#zip","text":"zip is a built-in function that takes iterables (can be zero or more), aggregates them in a tuple, and returns it. list1 = [1, 2, 3, 4] list2 = [4, 5, 6] # using min length for i in range(min(len(list1), len(list2))): print(f\"{list1[i]}: {list2[i]}\") # 1: 4, 2: 5, 3: 6 # or using zip for num1, num2 in zip(list1, list2): print(f\"{num1}: {num2}\") # 1: 4, 2: 5, 3: 6","title":"zip"},{"location":"python-beginner-intermediate-guide/#all","text":"all returns True if all elements of the iterable are true (or if the iterable is empty). # using all for num in nums: if num >= value: return False return True # or using all return all(num < value for num in nums)","title":"all"},{"location":"python-beginner-intermediate-guide/#any","text":"any returns True if any element of the iterable is true. If the iterable is empty, return False. # using any for num in nums: if num >= value: return True return False # or using any return any(num >= value for num in nums)","title":"any"},{"location":"python-beginner-intermediate-guide/#sorted","text":"sorted is a built-in function that returns a new sorted list from the elements of any iterable. nums = [5, 2, 3, 1, 4] # using sorted sorted_nums = sorted(nums) # [1, 2, 3, 4, 5] # or using sort nums.sort() # [1, 2, 3, 4, 5] The difference between sorted(iterable) and sort() is that sorted() returns a new list, while sort() modifies the list in place and returns None .","title":"sorted"},{"location":"python-beginner-intermediate-guide/#bin","text":"bin converts an integer number to a binary string prefixed with \"0b\". num = 5 print(bin(num)) # 0b101 # and converts it back to an integer using `int` print(int(bin(num), 2)) # 5","title":"bin"},{"location":"python-beginner-intermediate-guide/#map","text":"map(function, iterable) applies the function to all items in the iterable and returns a map object (which is an iterator). nums = [1, 2, 3, 4, 5] # using map squared_nums = list(map(lambda x: x ** 2, nums)) # [1, 4, 9, 16, 25]","title":"map"},{"location":"python-beginner-intermediate-guide/#reduce","text":"reduce(function, iterable) applies the function cumulatively to the items of the iterable, from left to right, so as to reduce the iterable to a single value. from functools import reduce def add(x, y): return x + y reduce (add, [1, 2, 3, 4, 5]) # 15 # which calcuates as (((1 + 2) + 3) + 4) + 5","title":"reduce"},{"location":"python-beginner-intermediate-guide/#filter","text":"filter(function, iterable) constructs an iterator from those elements of iterable for which function returns true. nums = [1, 2, 3, 4, 5] # using filter even_nums = list(filter(lambda x: x % 2 == 0, nums)) # [2, 4]","title":"filter"},{"location":"python-beginner-intermediate-guide/#reversed","text":"reversed returns a reverse iterator. The original iterable is not modified. nums = [1, 2, 3, 4, 5] # using reversed reversed_nums = list(reversed(nums)) # [5, 4, 3, 2, 1] # or using sort nums.sort(reverse=True) # [5, 4, 3, 2, 1]","title":"reversed"},{"location":"python-beginner-intermediate-guide/#data-structures","text":"","title":"Data Structures"},{"location":"python-beginner-intermediate-guide/#dictionary","text":"","title":"dictionary"},{"location":"python-beginner-intermediate-guide/#counter","text":"from collections import Counter nums = [1, 2, 3, 4, 5, 1, 2, 3] counter = Counter(nums) print(counter) # Counter({1: 2, 2: 2, 3: 2, 4: 1, 5: 1})","title":"counter"},{"location":"python-beginner-intermediate-guide/#set","text":"nums = [1, 2, 3, 4, 5] # using set unique_nums = set(nums) # {1, 2, 3, 4, 5} # or using list(dict.fromkeys) unique_nums = list(dict.fromkeys(nums)) # [1, 2, 3, 4, 5]","title":"set"},{"location":"python-beginner-intermediate-guide/#deque","text":"","title":"deque"},{"location":"python-beginner-intermediate-guide/#packages","text":"","title":"Packages"},{"location":"python-beginner-intermediate-guide/#bisect","text":"The module provides support for maintaining a list in sorted order without having to sort the list after each insertion. There are two main functions in the bisect module: bisect_left : Find the index where to insert an element to keep the list sorted. bisect_right : Find the index where to insert an element to keep the list sorted, but if the element is already present, it will be inserted to the right of the existing elements.","title":"bisect"},{"location":"python-beginner-intermediate-guide/#heapq","text":"The module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. heapify : Transform a list into a heap, in-place, in linear time. heappush : Push the value item onto the heap, maintaining the heap invariant. heappop : Pop and return the smallest item from the heap, maintaining the heap invariant.","title":"heapq"},{"location":"python-beginner-intermediate-guide/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"python-beginner-intermediate-guide/#if-not-_","text":"# check if list is empty if len(nums) == 0: print(\"List is empty\") # or if not nums: print(\"List is empty\")","title":"If (not) _"},{"location":"python-beginner-intermediate-guide/#multiplying-stringslists","text":"","title":"Multiplying strings/lists"},{"location":"python-beginner-intermediate-guide/#in-line-ifelse-statements","text":"","title":"In-line If/Else statements"},{"location":"python-beginner-intermediate-guide/#lru_cache-cache","text":"@lru_cache caches the result of function calls up to a certain size ( maxsize ). When the cache reaches this limit, the least recently used entries are discarded. Setting maxisize=None makes the cache unbounded. from functools import lru_cache @lru_cache(maxsize=None) def fibonacci(n): if n < 2: return n return fibonacci(n - 1) + fibonacci(n - 2) print(fibonacci(10)) # 55 With python 3.9+, you can use @cache instead of @lru_cache(maxsize=None) . from functools import cache @cache def fibonacci(n): if n < 2: return n return fibonacci(n - 1) + fibonacci(n - 2) print(fibonacci(10)) # 55","title":"@lru_cache, @cache"},{"location":"python-beginner-intermediate-guide/#floatinf-mathinf","text":"float('inf') is the same as math.inf , meaning positive infinity. float('-inf') is the same as -math.inf , meaning negative infinity.","title":"float('inf'), math.inf"},{"location":"special-notes/","text":"Special Notes Python variable scope nonlocal and global keywords are used to declare variables in a different scope. nonlocal is used to declare a variable in the nearest enclosing scope that is not global. global is used to declare a variable in the global scope (which is module level). Example of nonlocal keyword def outer_function(): x = 10 # Enclosing scope variable def inner_function(): nonlocal x # Declare x as nonlocal x += 5 print(\"Inner function:\", x) inner_function() print(\"Outer function:\", x) outer_function() Output: Inner function: 15 Outer function: 15 Example of global keyword x = 10 # Global variable def my_function(): global x # Declare x as global x += 5 print(\"Inside function:\", x) my_function() print(\"Outside function:\", x) Output: Inside function: 15 Outside function: 15 Shallow copy vs Deep copy Shallow copy : Creates a new object, but inserts references into it to the objects found in the original. Changes made to mutable objects in the shallow copy will affect the original object. Deep copy : Creates a new object and recursively adds copies of nested objects found in the original. Changes made to mutable objects in the deep copy will not affect the original object. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. import copy original = [1, 2, [3, 4]] shallow_copied = copy.copy(original) # this is the same as shallow_copied = original[:] or shallow_copied = original.copy() deep_copied = copy.deepcopy(original) shallow_copied[2][0] = 99 deep_copied[2][0] = 88 print(original) # [1, 2, [99, 4]] print(shallow_copied) # [1, 2, [99, 4]] print(deep_copied) # [1, 2, [88, 4]] Default Arguments Default arguments are evaluated once when the function is defined, not each time the function is called. If you use mutable default arguments (like lists or dictionaries), they will retain changes across function calls. To avoid this, use None as the default value and initialize the mutable object inside the function. def append_to_list(value, my_list=None): if my_list is None: # NOTE, you need to directly compare with None my_list = [] my_list.append(value) return my_list print(append_to_list(1)) # [1] print(append_to_list(2)) # [2] print(append_to_list(3, [4, 5])) # [4, 5, 3] def append_to_list(value, my_list=[]): my_list.append(value) return my_list print(append_to_list(1)) # [1] print(append_to_list(2)) # [1, 2] print(append_to_list(3, [4, 5])) # [4, 5, 3] Sorting Python's built-in sorting (sorted() and list.sort()) is a stable sort, and sorts lexicographically by default (using unicode value via ord() ). For tuple sorting, the first element is compared first, then the second, and so on. # Sorting a list of tuples data = [(1, 'apple'), (2, 'banana'), (1, 'orange')] sorted_data = sorted(data, key=lambda x: (x[0], x[1])) print(sorted_data) # [(1, 'apple'), (1, 'orange'), (2, 'banana')] Tuple vs List in leetcode Tuples: Immutable, cannot be changed after creation. Hashable, can be used as dictionary keys. Faster than lists for iteration and access. Typically represent fixed collections of heterogeneous data or pairs, coordinates, etc. Lists: Mutable, can be changed after creation. Not hashable, cannot be used as dictionary keys. Slower than tuples for iteration and access. Suitable for homogeneous sequences, dynamic-length collections, or when frequent modifications are needed. Use Tuple Use List Coordinate, (row, col) pairs When frequent insertion/deletion needed Keys in dicts/sets Temporary collections, stacks, queues Fixed-size states (memoization keys) Mutable states, paths, results *args and **kwargs *args allows you to pass a variable number of non-keyword arguments to a function. **kwargs allows you to pass a variable number of keyword arguments to a function. They are often used in function definitions to allow for flexible argument passing. def my_function(*args, **kwargs): print(\"Positional arguments:\", args) print(\"Keyword arguments:\", kwargs) my_function(1, 2, 3, a=4, b=5) # Output: # Positional arguments: (1, 2, 3) # Keyword arguments: {'a': 4, 'b': 5} def my_function(a, b, *args, **kwargs): print(\"a:\", a) print(\"b:\", b) print(\"Positional arguments:\", args) print(\"Keyword arguments:\", kwargs) my_function(1, 2, 3, 4, 5, x=6, y=7) # Output: # a: 1 # b: 2 # Positional arguments: (3, 4, 5) # Keyword arguments: {'x': 6, 'y': 7} The Zen of Python, by Tim Peters >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!","title":"Special Notes"},{"location":"special-notes/#special-notes","text":"","title":"Special Notes"},{"location":"special-notes/#python-variable-scope","text":"nonlocal and global keywords are used to declare variables in a different scope. nonlocal is used to declare a variable in the nearest enclosing scope that is not global. global is used to declare a variable in the global scope (which is module level).","title":"Python variable scope"},{"location":"special-notes/#example-of-nonlocal-keyword","text":"def outer_function(): x = 10 # Enclosing scope variable def inner_function(): nonlocal x # Declare x as nonlocal x += 5 print(\"Inner function:\", x) inner_function() print(\"Outer function:\", x) outer_function() Output: Inner function: 15 Outer function: 15","title":"Example of nonlocal keyword"},{"location":"special-notes/#example-of-global-keyword","text":"x = 10 # Global variable def my_function(): global x # Declare x as global x += 5 print(\"Inside function:\", x) my_function() print(\"Outside function:\", x) Output: Inside function: 15 Outside function: 15","title":"Example of global keyword"},{"location":"special-notes/#shallow-copy-vs-deep-copy","text":"Shallow copy : Creates a new object, but inserts references into it to the objects found in the original. Changes made to mutable objects in the shallow copy will affect the original object. Deep copy : Creates a new object and recursively adds copies of nested objects found in the original. Changes made to mutable objects in the deep copy will not affect the original object. Use copy.copy() for shallow copy and copy.deepcopy() for deep copy. import copy original = [1, 2, [3, 4]] shallow_copied = copy.copy(original) # this is the same as shallow_copied = original[:] or shallow_copied = original.copy() deep_copied = copy.deepcopy(original) shallow_copied[2][0] = 99 deep_copied[2][0] = 88 print(original) # [1, 2, [99, 4]] print(shallow_copied) # [1, 2, [99, 4]] print(deep_copied) # [1, 2, [88, 4]]","title":"Shallow copy vs Deep copy"},{"location":"special-notes/#default-arguments","text":"Default arguments are evaluated once when the function is defined, not each time the function is called. If you use mutable default arguments (like lists or dictionaries), they will retain changes across function calls. To avoid this, use None as the default value and initialize the mutable object inside the function. def append_to_list(value, my_list=None): if my_list is None: # NOTE, you need to directly compare with None my_list = [] my_list.append(value) return my_list print(append_to_list(1)) # [1] print(append_to_list(2)) # [2] print(append_to_list(3, [4, 5])) # [4, 5, 3] def append_to_list(value, my_list=[]): my_list.append(value) return my_list print(append_to_list(1)) # [1] print(append_to_list(2)) # [1, 2] print(append_to_list(3, [4, 5])) # [4, 5, 3]","title":"Default Arguments"},{"location":"special-notes/#sorting","text":"Python's built-in sorting (sorted() and list.sort()) is a stable sort, and sorts lexicographically by default (using unicode value via ord() ). For tuple sorting, the first element is compared first, then the second, and so on. # Sorting a list of tuples data = [(1, 'apple'), (2, 'banana'), (1, 'orange')] sorted_data = sorted(data, key=lambda x: (x[0], x[1])) print(sorted_data) # [(1, 'apple'), (1, 'orange'), (2, 'banana')]","title":"Sorting"},{"location":"special-notes/#tuple-vs-list-in-leetcode","text":"Tuples: Immutable, cannot be changed after creation. Hashable, can be used as dictionary keys. Faster than lists for iteration and access. Typically represent fixed collections of heterogeneous data or pairs, coordinates, etc. Lists: Mutable, can be changed after creation. Not hashable, cannot be used as dictionary keys. Slower than tuples for iteration and access. Suitable for homogeneous sequences, dynamic-length collections, or when frequent modifications are needed. Use Tuple Use List Coordinate, (row, col) pairs When frequent insertion/deletion needed Keys in dicts/sets Temporary collections, stacks, queues Fixed-size states (memoization keys) Mutable states, paths, results","title":"Tuple vs List in leetcode"},{"location":"special-notes/#args-and-kwargs","text":"*args allows you to pass a variable number of non-keyword arguments to a function. **kwargs allows you to pass a variable number of keyword arguments to a function. They are often used in function definitions to allow for flexible argument passing. def my_function(*args, **kwargs): print(\"Positional arguments:\", args) print(\"Keyword arguments:\", kwargs) my_function(1, 2, 3, a=4, b=5) # Output: # Positional arguments: (1, 2, 3) # Keyword arguments: {'a': 4, 'b': 5} def my_function(a, b, *args, **kwargs): print(\"a:\", a) print(\"b:\", b) print(\"Positional arguments:\", args) print(\"Keyword arguments:\", kwargs) my_function(1, 2, 3, 4, 5, x=6, y=7) # Output: # a: 1 # b: 2 # Positional arguments: (3, 4, 5) # Keyword arguments: {'x': 6, 'y': 7}","title":"*args and **kwargs"},{"location":"special-notes/#the-zen-of-python-by-tim-peters","text":">>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!","title":"The Zen of Python, by Tim Peters"},{"location":"string/","text":"String Chain string operations info = \" John Doe, 30, New York \" formatted_info = info.strip() formatted_info = formatted_info.upper() formatted_info = formatted_info.split(',') print(formatted_info) # ['JOHN DOE', ' 30', ' NEW YORK'] # chained operations formatted_info = info.strip().upper().split(\",\") print(formatted_info) # ['JOHN DOE', ' 30', ' NEW YORK'] ''.join() when creating a single string for list elements list_of_strings = ['Hello', 'World'] joined_string = ''.join(list_of_strings) # vs res = '' for string in list_of_strings: res += string Case Conversion lower() , 'HELLO WORLD'.lower() # 'hello world' upper() , 'hello world'.upper() # 'HELLO WORLD' title() , 'hello world'.title() # 'Hello World' capitalize() , 'hello world'.capitalize() # 'Hello world' swapcase() , 'HeLLo'.swapcase() # 'hEllO' Searching and Counting .find(sub[, start[, end]]) 'hello world'.find('world') # 6 .rfind(sub[, start[, end]]) 'hello world world'.rfind('world') # 12 .count(sub[, start[, end]]) 'hello world'.count('o') # 2 Trimming and Padding .strip([chars]) ' hello world '.strip() # 'hello world' .lstrip([chars]) ' hello world '.lstrip() # 'hello world ' lstrip - '-42'.lstrip('-') # '42' .rstrip([chars]) ' hello world '.rstrip() # ' hello world' .ljust(width[, fillchar]) 'hello'.ljust(10, '-') # 'hello-----' .rjust(width[, fillchar]) 'hello'.rjust(10, '-') # '-----hello' .zfill(width[, fillchar]) '42'.zfill(5) # '00042' Replacement .replace(old, new[, count]) 'hello world'.replace('world', 'Python') # 'hello Python' Splitting and Joining .split([sep[, maxsplit]]) 'hello world'.split() # ['hello', 'world'] .rsplit([sep[, maxsplit]]) 'one,two,three'.rsplit(',', 1) # ['one,two', 'three'] join(iterable) '-'.join(['hello', 'world']) # 'hello-world' Testing and Validation .startswith(prefix[, start[, end]]) 'hello world'.startswith('hello') # True .endswith(suffix[, start[, end]]) 'hello world'.endswith('world') # True .isalnum() 'hello123'.isalnum() # True .isalpha() 'hello'.isalpha() # True .isdigit() '123'.isdigit() # True .isnumeric() '\u2155'.isnumeric() # True .isspace() ' '.isspace() # True MIscellaneous len(str) len('hello') # 5 ord(char) and chr(codepoint) ord('A') # 65 chr(65) # 'A' eval() eval() evaluates a string as a Python expression and returns the result. It can be dangerous if used with untrusted input. result = eval('2 + 3 * 4') # 14 result = eval('x + y', {'x': 1, 'y': 2}) # 3 result = eval('x + 2'.replace('x', '2')) # 4","title":"String"},{"location":"string/#string","text":"","title":"String"},{"location":"string/#chain-string-operations","text":"info = \" John Doe, 30, New York \" formatted_info = info.strip() formatted_info = formatted_info.upper() formatted_info = formatted_info.split(',') print(formatted_info) # ['JOHN DOE', ' 30', ' NEW YORK'] # chained operations formatted_info = info.strip().upper().split(\",\") print(formatted_info) # ['JOHN DOE', ' 30', ' NEW YORK']","title":"Chain string operations"},{"location":"string/#join-when-creating-a-single-string-for-list-elements","text":"list_of_strings = ['Hello', 'World'] joined_string = ''.join(list_of_strings) # vs res = '' for string in list_of_strings: res += string","title":"''.join() when creating a single string for list elements"},{"location":"string/#case-conversion","text":"lower() , 'HELLO WORLD'.lower() # 'hello world' upper() , 'hello world'.upper() # 'HELLO WORLD' title() , 'hello world'.title() # 'Hello World' capitalize() , 'hello world'.capitalize() # 'Hello world' swapcase() , 'HeLLo'.swapcase() # 'hEllO'","title":"Case Conversion"},{"location":"string/#searching-and-counting","text":"","title":"Searching and Counting"},{"location":"string/#findsub-start-end","text":"'hello world'.find('world') # 6","title":".find(sub[, start[, end]])"},{"location":"string/#rfindsub-start-end","text":"'hello world world'.rfind('world') # 12","title":".rfind(sub[, start[, end]])"},{"location":"string/#countsub-start-end","text":"'hello world'.count('o') # 2","title":".count(sub[, start[, end]])"},{"location":"string/#trimming-and-padding","text":"","title":"Trimming and Padding"},{"location":"string/#stripchars","text":"' hello world '.strip() # 'hello world'","title":".strip([chars])"},{"location":"string/#lstripchars","text":"' hello world '.lstrip() # 'hello world ' lstrip - '-42'.lstrip('-') # '42'","title":".lstrip([chars])"},{"location":"string/#rstripchars","text":"' hello world '.rstrip() # ' hello world'","title":".rstrip([chars])"},{"location":"string/#ljustwidth-fillchar","text":"'hello'.ljust(10, '-') # 'hello-----'","title":".ljust(width[, fillchar])"},{"location":"string/#rjustwidth-fillchar","text":"'hello'.rjust(10, '-') # '-----hello'","title":".rjust(width[, fillchar])"},{"location":"string/#zfillwidth-fillchar","text":"'42'.zfill(5) # '00042'","title":".zfill(width[, fillchar])"},{"location":"string/#replacement","text":"","title":"Replacement"},{"location":"string/#replaceold-new-count","text":"'hello world'.replace('world', 'Python') # 'hello Python'","title":".replace(old, new[, count])"},{"location":"string/#splitting-and-joining","text":"","title":"Splitting and Joining"},{"location":"string/#splitsep-maxsplit","text":"'hello world'.split() # ['hello', 'world']","title":".split([sep[, maxsplit]])"},{"location":"string/#rsplitsep-maxsplit","text":"'one,two,three'.rsplit(',', 1) # ['one,two', 'three']","title":".rsplit([sep[, maxsplit]])"},{"location":"string/#joiniterable","text":"'-'.join(['hello', 'world']) # 'hello-world'","title":"join(iterable)"},{"location":"string/#testing-and-validation","text":"","title":"Testing and Validation"},{"location":"string/#startswithprefix-start-end","text":"'hello world'.startswith('hello') # True","title":".startswith(prefix[, start[, end]])"},{"location":"string/#endswithsuffix-start-end","text":"'hello world'.endswith('world') # True","title":".endswith(suffix[, start[, end]])"},{"location":"string/#isalnum","text":"'hello123'.isalnum() # True","title":".isalnum()"},{"location":"string/#isalpha","text":"'hello'.isalpha() # True","title":".isalpha()"},{"location":"string/#isdigit","text":"'123'.isdigit() # True","title":".isdigit()"},{"location":"string/#isnumeric","text":"'\u2155'.isnumeric() # True","title":".isnumeric()"},{"location":"string/#isspace","text":"' '.isspace() # True","title":".isspace()"},{"location":"string/#miscellaneous","text":"","title":"MIscellaneous"},{"location":"string/#lenstr","text":"len('hello') # 5","title":"len(str)"},{"location":"string/#ordchar-and-chrcodepoint","text":"ord('A') # 65 chr(65) # 'A'","title":"ord(char) and chr(codepoint)"},{"location":"string/#eval","text":"eval() evaluates a string as a Python expression and returns the result. It can be dangerous if used with untrusted input. result = eval('2 + 3 * 4') # 14 result = eval('x + y', {'x': 1, 'y': 2}) # 3 result = eval('x + 2'.replace('x', '2')) # 4","title":"eval()"},{"location":"time-complexity-estimation/","text":"Time Complexity Estimation for LeetCode Problems Complexity Upper Bound Possible Algorithms Typical Constraints (LeetCode) $O(n \\cdot 2^n)$ Brute-force DFS, Bitmask $n \\leq 20$ $O(n^3)$ Brute-force, Floyd-Warshall, 3-D DP $n \\leq 300$ $O(n^2)$ 2-D DP, BFS, DFS $n \\leq 1000$ $O(n \\log n)$ Sort, Binary Search, Dijkstra $n \\leq 10^5$ $O(n)$ Hashing, Prefix Sum, Union-Find, Two-Pointer $n \\leq 10^6$ $O(\\log n)$ Binary Search $n \\leq 10^{18}$ Explanation $O(n \\cdot 2^n)$ : Usually involves exploring all subsets or permutations. Commonly solved using bitmasking or DFS with pruning. Limited to very small inputs due to exponential growth. $O(n^3)$ : Often used in problems involving Floyd-Warshall for all-pairs shortest paths or DP problems with three-dimensional state arrays. $O(n^2)$ : Suitable for typical matrix problems, DP with 2-D state arrays, or traversals involving nested loops. BFS or DFS with adjacency matrices or grids often fall under this complexity. $O(n \\log n)$ : Algorithms requiring sorting (Merge sort, Quick sort), binary search, or priority queue-based algorithms like Dijkstra fall here. $O(n)$ : Optimal complexity involving linear traversals, hashing to achieve constant-time lookups, two-pointers, prefix sums for cumulative calculations, or union-find for disjoint set problems. $O(\\log n)$ : Represents highly efficient search-based algorithms, mainly binary search on large sorted or implicitly sorted datasets.","title":"Time Complexity Estimation"},{"location":"time-complexity-estimation/#time-complexity-estimation-for-leetcode-problems","text":"Complexity Upper Bound Possible Algorithms Typical Constraints (LeetCode) $O(n \\cdot 2^n)$ Brute-force DFS, Bitmask $n \\leq 20$ $O(n^3)$ Brute-force, Floyd-Warshall, 3-D DP $n \\leq 300$ $O(n^2)$ 2-D DP, BFS, DFS $n \\leq 1000$ $O(n \\log n)$ Sort, Binary Search, Dijkstra $n \\leq 10^5$ $O(n)$ Hashing, Prefix Sum, Union-Find, Two-Pointer $n \\leq 10^6$ $O(\\log n)$ Binary Search $n \\leq 10^{18}$","title":"Time Complexity Estimation for LeetCode Problems"},{"location":"time-complexity-estimation/#explanation","text":"$O(n \\cdot 2^n)$ : Usually involves exploring all subsets or permutations. Commonly solved using bitmasking or DFS with pruning. Limited to very small inputs due to exponential growth. $O(n^3)$ : Often used in problems involving Floyd-Warshall for all-pairs shortest paths or DP problems with three-dimensional state arrays. $O(n^2)$ : Suitable for typical matrix problems, DP with 2-D state arrays, or traversals involving nested loops. BFS or DFS with adjacency matrices or grids often fall under this complexity. $O(n \\log n)$ : Algorithms requiring sorting (Merge sort, Quick sort), binary search, or priority queue-based algorithms like Dijkstra fall here. $O(n)$ : Optimal complexity involving linear traversals, hashing to achieve constant-time lookups, two-pointers, prefix sums for cumulative calculations, or union-find for disjoint set problems. $O(\\log n)$ : Represents highly efficient search-based algorithms, mainly binary search on large sorted or implicitly sorted datasets.","title":"Explanation"}]}